1. Create Buttons
- Import
- Save to a database?

2. Import File (CSV or JSON)

3. Check if CSV or JSON
- Gaining information from the uri
- ContentResolver has security issues but more commonly used
- DocumentFile is more secure (but needs contentResolver still)
    -This doesn't open the file easily to read
    -Need to use ContentResolver and protect uri through validation
        - https://developer.android.com/privacy-and-security/risks/content-resolver#java
    -Android Studio Uri objects


4. Determine how to store the data
- A CSV and JSON store data differently
- Define an optimal way to parse
- Or Research a library for external use
    1. OpenCSV -> Can use for converting CSV
    2. Gson -> Can use for converting JSON
    3. Jackson -> Can use for converting JSON

4.1 Parsing a CSV File
- While Manual parsing is a few lines of code
    - This will not include edge cases
    - Take longer to determine all edge cases
    - Can do if there is more time once complete
- OpenCSV is shorter and has built in functions to help

4.2 Parsing a JSON File
- Options
    -Jackson
    -Gson
    -JSON.org
    -Manual
Manual parsing is a lot more code, especially due
to not knowing fields
- Jackson is a library that uses ObjectMapper
    - It handles type, missing fields, name, null, etc.
    - https://www.baeldung.com/jackson


5. Send to specific Reader

6. CONVERT TO PARSED DATA

7. Save to Database or Local

8.

Questions {
Could arrays in JSON be supported or not?
    - What are the edge cases around that?
        - Representing Objects and Arrays in CSV can be very difficult
        for the sake of the exercize. Arrays are not supported
        in this application where we are strictly handling strings,
        ints, booleans.

        - Look into future Validation step to check correct data types
}


https://developer.android.com/privacy-and-security/risks/content-resolver
SECURITY CODE: future addition {
boolean isValidFile(Context ctx, ParcelFileDescriptor pfd, Uri fileUri) throws ErrnoException, IOException {
        // Canonicalize to resolve symlinks and path traversals
        String fdCanonical = new File(fileUri.getPath()).getCanonicalPath();

        StructStat pfdStat = Os.fstat(pfd.getFileDescriptor());

        // Lstat doesn't follow the symlink.
        StructStat canonicalFileStat = Os.lstat(fdCanonical);

        // Since we canonicalized (followed the links) the path already,
        // the path shouldn't point to symlink unless it was changed in the meantime
        if (OsConstants.S_ISLNK(canonicalFileStat.st_mode)) {
            return false;
        }

        boolean sameFile =
                pfdStat.st_dev == canonicalFileStat.st_dev && pfdStat.st_ino == canonicalFileStat.st_ino;
        if (!sameFile) {
            return false;
        }
        return !isBlockedPath(ctx, fdCanonical);
    }
    boolean isBlockedPath(Context ctx, String fdCanonical) {
        // Paths that should rarely be exposed
        if (fdCanonical.startsWith("/proc/") || fdCanonical.startsWith("/data/misc/")) {
            return true;
        }
        return false;
        // Implement logic to block desired directories. For example, specify
        // the entire app data/ directory to block all access.
    }
}





